---
title: "ECo 602 - Analysis of Environmental Data"
subtitle: "Final Project"
author: "Roberto Navarrete Arias"
date: "Fall 2020"
output:
  html_document:
    theme: readable
    toc: TRUE
    toc_float: TRUE
editor_options:
  chunk_output_type: console
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
options(knitr.duplicate.label = TRUE)
```

Everything above this line is the header.


<!-- The following text won't be displayed in your document.  It tells R how to make nicer looking buttons for your tabbed content. -->

<style type="text/css" rel="stylesheet">

.btn {
    border-width: 0 0 0 0;
    font-weight: normal;
    text-transform: none;
}

.btn-default {
    color: #2ecc71;
    background-color: #ffffff;
    border-color: #ffffff;
}
</style>


Use this document as a template to build your final project.

If you've already created the file index.Rmd in your docs folder, you can paste everything below the header into that document.

If you don't yet have an index.Rmd file, save this document as index.Rmd in the docs folder of your main class folder.

Edit this template to fill in your own content.


# Introduction

Type a brief introduction here.


# Functions 1: Data Structure Functions {.tabset .tabset-pills}

Look at the source code for the final project template, you'll notice the text:

{.tabset .tabset-pills}

This creates tabbed content for all the following sections that are one-level below.

- If you include them on a primary header (one #), all of the subsequent secondary headers will in tabs.




## `c()`

The function `c()` *combines* or *concatenates* its arguments into a vector (a 1-dimensional data structure consisting of 1 or more elements).

- All of the elements must be of the same *type*.
  - I can't combine character and numeric types in the same call to `c()`

Here's two examples using numeric and character data types:

```{r}
# Create a vector of numbers:
num_vec  = c(1, 4, 8, 9, 13)

# Create a vector of characters:
char_vec = c("a", "fish", "data is cool")
```

I can show the contents of a vector by typing the name of the vector, or using the `print()` function.

```{r}
# Typing the name of the vector into the console prints the contents
num_vec

# The print() function accomplishes the same task:
print(char_vec)
```


## `data.frame()`

The function `data.frame()` *combines* or *concatenates* its vectorized arguments into a data frame (a 2-dimensional data structure consisting of at least 2 elements).

  - The elements can be of the same or of a different *type (numerical, character, logical)*.

Here's two examples using numeric and character data types:

```{r data_frame_example_1}

#Type your data frame example here.

dat_1 = data.frame(letters = c("b", "w", "B"),
           numbers_1 = c(34, 6, 123454))

#I can print the contents by typing the names of the data frame

dat_1

#Subset a column by name

dat_1$letters

#Subset a column by place.

##I should leave the first space blank because it refers to rows and only fill the second space, that refers to columns. Since I am writing the number "2", I will be getting the second column.

dat_1[,2]

#Subset an element by place.

##In the first space, I should write the row where the element is located and in the second space, the column where the element is located. Since I want to get the element "123454", I will be writing "3" for row and "2" for column.

dat_1[3,2]

```

## `matrix()`

```{r matrix_example_1}



```

Type your matrix example here.


## `length()`


## `nrow()`


## `ncol()`


## `dim()`


# Functions 2: Numerical Data Exploration  {.tabset .tabset-pills}

## `summary()`

## `mean()`

## `sd()`
 


# Functions 3: Graphical Data Exploration {.tabset .tabset-pills}

See the final project description for a list of the required functions.

## `plot()`

I can use `plot()` to create scatterplots!

```{r scatterplot_1, fig.asp=1.5, fig.height=20}

#load the penguins package:

require(palmerpenguins)

#using formula notation
#pch argument to change the symbol

plot(bill_length_mm ~ body_mass_g,
     data = penguins,
     pch = 16)

```
## `boxplot()`

## `hist()`

## `par()` and ## `mfrow=`

# Functions 4: Distribution Functions {.tabset .tabset-pills}

## `dnorm()`

## `pnorm()`

## `qnorm()`

## `dbinom()`

## `pbinom()`

## `qbinom()`


# Functions 5: Other Functions {.tabset .tabset-pills}

## `set()`

## `libary() and require()`

## `read.csv()`

```{r read.csv}

require(here)


read.csv(here("data", "delomys.csv"))

delomys = read.csv(here("data", "delomys.csv"))

```

# Part 2: Data Anaylsis

## Data Exploration

### Numerical Exploration

```{r numerical exploration}

# Use summary() on the body mass and body length data columns in the Delomys data set to display summary statistics.

summary(delomys)

# Perform a test of normality on the body mass and length columns. You can use shapiro.test()

shapiro.test(delomys$body_mass)

shapiro.test(delomys$body_length)

```

### Graphical Exploration

Using code chunks, create the following plots.

```{r fig.height=7, fig.width=11, fig.aspect=10}

# A scatterplot of body mass and body length

plot(body_mass ~ body_length, data = delomys)

```

```{r }

# A histogram of body mass

hist(delomys$body_mass)

```

```{r }

# A histogram of body length

hist(delomys$body_length)

```

```{r }

# A conditional boxplot of body mass, conditioned on species

boxplot(body_mass ~ binomial, data = delomys)

```

```{r }

# A conditional boxplot of body mass, conditioned on sex

boxplot(body_mass ~ sex, data = delomys)

```

```{r }

# A conditional boxplot of body mass,  conditioned on both species and sex

boxplot(body_mass ~ binomial*sex, data = delomys)

```

## Model Building

We know that the normality assumption applies to the residual values after we fit a model.

Using a code chunk, fit 5 models using lm():

```{r }

# Model 1: simple linear regression body_length ~ body_mass


lm(body_mass ~ body_length, data = delomys)

fit1 = lm(body_mass ~ body_length, data = delomys)

fit1

```

```{r }

# Model 2: 1-way ANOVA body_mass ~ sex

lm(body_mass ~ sex, data = delomys)

fit2 = lm(body_mass ~ sex, data = delomys)

fit2

```

```{r }

# Model 3: 1-way ANOVA body_mass ~ binomial

lm(body_mass ~ binomial, data = delomys)

fit3 = lm(body_mass ~ binomial, data = delomys)

fit3

```

```{r }

# Model 4: 2-way additive ANOVA body_mass ~ sex + binomial

lm(body_mass ~ sex + binomial, data = delomys)

fit4 = lm(body_mass ~ sex + binomial, data = delomys)

fit4

```

```{r }

# Model 5: 2-way factorial ANOVA body_mass ~ sex * binomial

lm(body_mass ~ sex * binomial, data = delomys)

fit5 = lm(body_mass ~ sex * binomial, data = delomys)

fit5

```

## Model Diagnostics

Letâ€™s check whether our models fulfill the assumption of normality of the residuals.

First, use a graphical approach: plot histograms of the model residuals.

You can retrieve the model residuals using the residuals() function. For example, I could get the residuals from the first model using residuals(fit1).
Use a code chunk to create histograms of the residuals of each of the 5 models.

Next, use shapiro.test() on each model to test the null hypothesis that the residuals are drawn from a normally-distributed population.

```{r }

# Model 1: simple linear regression body_length ~ body_mass

hist(residuals(fit1))

shapiro.test(residuals(fit1))
```

```{r }

# Model 2: 1-way ANOVA body_mass ~ sex

hist(residuals(fit2))

shapiro.test(residuals(fit2))

```

```{r }

# Model 3: 1-way ANOVA body_mass ~ binomial

hist(residuals(fit3))

shapiro.test(residuals(fit3))

```

```{r }

# Model 4: 2-way additive ANOVA body_mass ~ sex + binomial

hist(residuals(fit4))

shapiro.test(residuals(fit4))

```

```{r }

# Model 5: 2-way factorial ANOVA body_mass ~ sex * binomial

hist(residuals(fit5))

shapiro.test(residuals(fit5))

```

## Model Interpretation

### Body Length

Print the model coefficient table using summary() and answer the following:

```{r }

# Model 1: simple linear regression body_length ~ body_mass

knitr::kable(coef(summary(fit1)))

```

### Body Mass: Model Coefficients

Print the model coefficient tables for each of the body mass model fits.

```{r }

# Model 2: 1-way ANOVA body_mass ~ sex

knitr::kable(coef(summary(fit2)))

```

```{r }

# Model 3: 1-way ANOVA body_mass ~ binomial

knitr::kable(coef(summary(fit3)))

```

```{r }

# Model 4: 2-way additive ANOVA body_mass ~ sex + binomial

knitr::kable(coef(summary(fit4)))

```

```{r }

# Model 5: 2-way factorial ANOVA body_mass ~ sex * binomial

knitr::kable(coef(summary(fit5)))

```

### Body Mass: ANOVA

Print the ANOVA tables for each of the body mass models.

```{r }


# Model 2: 1-way ANOVA body_mass ~ sex

knitr::kable(anova(fit2))

```

```{r }

# Model 3: 1-way ANOVA body_mass ~ binomial

knitr::kable(anova(fit3))

```

```{r }

# Model 4: 2-way additive ANOVA body_mass ~ sex + binomial

knitr::kable(anova(fit4))

```

```{r }

# Model 5: 2-way factorial ANOVA body_mass ~ sex * binomial

knitr::kable(anova(fit5))

```

## Model Comparison: Body Mass

You built four different models of body mass. How do you choose the best one?

One option is to choose the model with the lowest AIC. You can calculate AIC using the appropriately named AIC() function.

Create a code chunk that calculates the AIC values for each of the body mass models.

```{r }
# Model 2: 1-way ANOVA body_mass ~ sex

AIC(fit2)

# Model 3: 1-way ANOVA body_mass ~ binomial

AIC(fit3)

# Model 4: 2-way additive ANOVA body_mass ~ sex + binomial

AIC(fit4)

# Model 5: 2-way factorial ANOVA body_mass ~ sex * binomial

AIC(fit5)
```