---
title: "ECo 602 - Analysis of Environmental Data"
subtitle: "Final Project"
author: "Roberto Navarrete Arias"
date: "Fall 2020"
output:
  html_document:
    theme: readable
    toc: TRUE
    toc_float: TRUE
editor_options:
  chunk_output_type: console
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
options(knitr.duplicate.label = TRUE)
```




<!-- The following text won't be displayed in your document.  It tells R how to make nicer looking buttons for your tabbed content. -->

<style type="text/css" rel="stylesheet">

.btn {
    border-width: 0 0 0 0;
    font-weight: normal;
    text-transform: none;
}

.btn-default {
    color: #2ecc71;
    background-color: #ffffff;
    border-color: #ffffff;
}
</style>


# Introduction

Type a brief introduction here.


# Functions 1: Data Structure Functions {.tabset .tabset-pills}

Look at the source code for the final project template, you'll notice the text:

{.tabset .tabset-pills}

This creates tabbed content for all the following sections that are one-level below.

- If you include them on a primary header (one #), all of the subsequent secondary headers will in tabs.




## `c()`

The function `c()` *combines* or *concatenates* its arguments into a vector (a 1-dimensional data structure consisting of 1 or more elements).

  - All of the elements must be of the same *type*.
  - I can't combine character and numeric types in the same call to `c()`

Here's two examples using numeric and character data types:

```{r}
# Create a vector of numbers:
num_vec  = c(1, 4, 8, 9, 13)

# Create a vector of characters:
char_vec = c("a", "fish", "data is cool")
```

#I can show the contents of a vector by typing the name of the vector, or using the `print()` function.

```{r}
# Typing the name of the vector into the console prints the contents
num_vec

# The print() function accomplishes the same task:
print(char_vec)
```


## `data.frame()`

The function `data.frame()` *combines* or *concatenates* its vectorized arguments into a data frame (a 2-dimensional data structure consisting of at least 2 elements).

  - The elements can be of the same or of a different *type (numerical, character, logical)*.

Here's two examples using numeric and character data types:

```{r data_frame_example_1}

#Type your data frame example here. In the arguments, we write the vectors that will be part of this data frame. For this case, the first vector will be of character type and the second vector of numerical type.

dat_1 = data.frame(letters = c("b", "w", "B"),
           numbers_1 = c(34, 6, 123454))

#I can print the contents by typing the names of the data frame

dat_1

#Subset a column by name

dat_1$letters

#Subset a column by place.

##I should leave the first space blank because it refers to rows and only fill the second space, that refers to columns. Since I am writing the number "2", I will be getting the second column.

dat_1[,2]

#Subset a row by place.

##I should leave the second space blank because it refers to columns and only fill the first space, that refers to rows. Since I am writing the number "3", I will be getting the third row.

dat_1[3,]

#Subset an element by place.

##In the first space, I should write the row where the element is located and in the second space, the column where the element is located. Since I want to get the element "123454", I will be writing "3" for row and "2" for column.

dat_1[3,2]

```

## `matrix()`

The function `matrix()` *combines* or *concatenates* its vectorized arguments into a matrix (a 2-dimensional data structure consisting of at least 2 elements).

   - All of the elements must be of the same *type*..

Here's two examples using numeric and character data types:

```{r matrix_example_1}

#Type your matrix example here. In the first argument, we write the elements of the matrix. In this case, the matrix will be of numerical type with numbers from 1 to 21. In the second argument, we put the number of rows that the matrix will have and in the third argument, the number of columns.

mat_1 = matrix(1:21, 
               nrow = 3, 
               ncol = 7)


#I can print the contents by typing the names of the matrix

mat_1

#The matrix is filled by column by default. If we want to fill it by row, we can add the byrow argument with a logical value of TRUE.

mat_2 = matrix(1:21, nrow = 3, 
               ncol = 7, 
               byrow = TRUE)

mat_2
```

## `length()`

```{r length_example_1}

#Function "length" is used to get the number of elements of vectors

length(num_vec)

#It does not matter if the elements of the vector are not numerical

length(char_vec)

#It can also be used for other R objects, such as matrix

length(mat_2)

```

## `nrow()`

```{r nrow_example_1}

#Function "nrow" returns the number of rows present in an R object, like a matrix or a data frame

nrow(mat_1)

nrow(dat_1)
```

## `ncol()`

```{r ncol_example_1}

#Function "ncol" returns the number of columns present in an R object, like a matrix or a data frame

ncol(mat_1)

ncol(dat_1)
```

## `dim()`

```{r dim_example_1}

#Function "dim" retrieves the dimensions of an R object, like a matrix or a data frame. The first element shown will be the number of rows and the second eement shown will be the number of columns

dim(mat_1)

dim(dat_1)
```

# Functions 2: Numerical Data Exploration  {.tabset .tabset-pills}

## `summary()`

Function "summary" shows summaries of the results of various model fitting functions. 

```{r summary_example_1}

#Load the penguins package:

require(palmerpenguins)

#Run the summary function for the penguins data set to get general information about the data set

summary(penguins)
```

## `mean()`

Function "mean" shows the mean value for a group of values

```{r mean_example_1}

#Run the mean function for the values of bill length (in mm) for the penguins data set to get the mean value of this group of values

#We include the argument na.rm = TRUE so the function can get the mean of the expressed values, ignoring the blank spaces

mean(penguins$bill_length_mm, na.rm = TRUE)
```

## `sd()`
 
Function "sd" shows the standard deviation value for a group of values

```{r sd_example_1}

#Run the sd function for the values of bill length (in mm) for the penguins data set to get the mean value of this group of values

#We include the argument na.rm = TRUE so the function can get the standard deviation of the expressed values, ignoring the blank spaces

sd(penguins$bill_length_mm, na.rm = TRUE)
```

# Functions 3: Graphical Data Exploration {.tabset .tabset-pills}

See the final project description for a list of the required functions.

## `plot()`

I can use `plot()` to create scatterplots!

```{r scatterplot_1, fig.asp=0.75, fig.height=20}

#load the penguins package:

require(palmerpenguins)

#using formula notation
#pch argument to change the symbol

plot(bill_length_mm ~ body_mass_g,
     data = penguins,
     pch = 16)

```
## `boxplot()`

## `hist()`

## `par()` and ## `mfrow=`

# Functions 4: Distribution Functions {.tabset .tabset-pills}

## `dnorm()`

## `pnorm()`

## `qnorm()`

## `dbinom()`

## `pbinom()`

## `qbinom()`


# Functions 5: Other Functions {.tabset .tabset-pills}

## `set()`

## `libary() and require()`

## `read.csv()`

```{r read.csv}

require(here)


read.csv(here("data", "delomys.csv"))

delomys = read.csv(here("data", "delomys.csv"))

```

# Part 2: Data Anaylsis

## Data Exploration

### Numerical Exploration

```{r numerical exploration}

# Use summary() on the body mass and body length data columns in the Delomys data set to display summary statistics.

summary(delomys)

# Perform a test of normality on the body mass and length columns. You can use shapiro.test()

shapiro.test(delomys$body_mass)

shapiro.test(delomys$body_length)

```

### Graphical Exploration

Using code chunks, create the following plots.

```{r fig.height=7, fig.width=11, fig.aspect=10}

# A scatterplot of body mass and body length

plot(body_mass ~ body_length, 
     data = delomys,
     main = "Scatterplot of Delomys species:
     Body Length vs. Body Mass",
     xlab = "Body Length",
     ylab = "Body Mass")

```

**Qualitatively describe the relationship between body mass and length.
Does the relationship seem linear, curved, nonexistent?**

The relationship seems to be linear although there are some larger body length values (over 200) for average body mass values. However, we do see a linear pattern for most of the values.

```{r }

# A histogram of body mass

hist(delomys$body_mass,
     main = "Histogram of Delomys species: Body Mass",
     xlab = "Body Mass")

```

```{r }

# A histogram of body length

hist(delomys$body_length,
     main = "Histogram of Delomys species: Body Length",
     xlab = "Body Length")

```

**Qualitatively describe the shapes of the histograms.
Do the data appear normally-distributed? Explain why or why not.**

The Histogram of Delomys species: Body Mass does have a very normal pattern, since most of the values are concentrated in the center of the distribution and the amount of values decrease in both tails.

As for the Histogram of Delomys species: Body Length, we can see an approximate normal pattern because most values are concentrated in what seems to be the center of the distribution. However, it is not as clearly defined as the previous histogram was, since in the tail located in the right part of the distribution there are ranges with no values at all (160-180, 180-200), but most extreme ranges (200-220, 220-240) do present values, although they are not many.

**Using both the histograms and normality tests, do you think the (unconditioned) body masses and body length are normally-distributed?
Contrast your visual assessment of normality to the results of the numerical normality tests.**

The p-value obtained by the Shapiro test for the body mass values is 4.33e-05 and the p-value obtained by the Shapiro test for the body length values is 2.2e-16. Both are very small p-values, that would let us reject the null hypothesis of the values, both for body mass and body length (values being normally distributed). However, there is a conflict between these values and the graphical interpretation, because in the histograms we can see normal patterns, although the normal pattern is more clearly defined for the histogram of body mass than for the histogram of body length. Since there is a conflict, I cannot assure that the body masses and body lengths are normally-distributed, but I think that the data in the graphical exploration in this case is normal enough to assume that the values can be normally distributed.

```{r }

# A conditional boxplot of body mass, conditioned on species

boxplot(body_mass ~ binomial, 
        data = delomys,
        main = "Boxplot of Delomys Body Mass:
Conditioned on Species",
        xlab = "Species",
        ylab = "Body Mass")

```

```{r }

# A conditional boxplot of body mass, conditioned on sex

boxplot(body_mass ~ sex, 
        data = delomys,
        main = "Boxplot of Delomys Body Mass:
Conditioned on Sex",
        xlab = "Sex",
        ylab = "Body Mass")

```

```{r }

# A conditional boxplot of body mass,  conditioned on both species and sex

boxplot(body_mass ~ binomial*sex, 
        data = delomys, 
        main = "Boxplot of Delomys species:
Conditioned on Species and Sex",
        xlab = "Species : Sex",
        ylab = "Body Mass",
        names = c("Dorsalis:F", "Sublineatus:F", "Dorsalis:M", "Sublineatus:M"))

```

**Examine the conditional boxplots. Describe any graphical evidence you see for body mass differences based on species and/or sex.**

In the boxplot conditioned on species, we can appreciate that the Delomys dorsalis species seems to have heavier body masses than the Delomys sublineatus species.

As for the boxplot conditioned on sex, we can see that male individuals seem to have heavier body masses than female individuals in the distribution.

Finally, in the boxplot conditioned both on species and sex we can see the same pattern repeated, because if we compare between species of the same sex, we notice that the Delomys dorsalis individuals seem to be heavier in both cases. Also, if we compare between sexes of the same species, the boxplots show that the male individuals seem to be heavier than the female individuals.

## Model Building

We know that the normality assumption applies to the residual values after we fit a model.

Using a code chunk, fit 5 models using lm():

```{r }

# Model 1: simple linear regression body_length ~ body_mass

fit1 = lm(body_length ~ body_mass, data = delomys)

fit1

```

```{r }

# Model 2: 1-way ANOVA body_mass ~ sex

fit2 = lm(body_mass ~ sex, data = delomys)

fit2

```

```{r }

# Model 3: 1-way ANOVA body_mass ~ binomial

fit3 = lm(body_mass ~ binomial, data = delomys)

fit3

```

```{r }

# Model 4: 2-way additive ANOVA body_mass ~ sex + binomial

fit4 = lm(body_mass ~ sex + binomial, data = delomys)

fit4

```

```{r }

# Model 5: 2-way factorial ANOVA body_mass ~ sex * binomial

fit5 = lm(body_mass ~ sex * binomial, data = delomys)

fit5

```

## Model Diagnostics

Let’s check whether our models fulfill the assumption of normality of the residuals.

First, use a graphical approach: plot histograms of the model residuals.

You can retrieve the model residuals using the residuals() function. For example, I could get the residuals from the first model using residuals(fit1).
Use a code chunk to create histograms of the residuals of each of the 5 models.

Next, use shapiro.test() on each model to test the null hypothesis that the residuals are drawn from a normally-distributed population.

```{r }

# Model 1: simple linear regression body_length ~ body_mass

hist(residuals(fit1),
     main = "Histogram of residuals for 
     Model 1: simple linear regression body_length ~ body_mass",
     xlab = "Residuals for Model 1: simple linear regression body_length ~ body_mass")

shapiro.test(residuals(fit1))
```

```{r }

# Model 2: 1-way ANOVA body_mass ~ sex

hist(residuals(fit2),
     main = "Histogram of residuals for 
     Model 2: 1-way ANOVA body_mass ~ sex",
     xlab = "Residuals for Model 2: 1-way ANOVA body_mass ~ sex")

shapiro.test(residuals(fit2))

```

```{r }

# Model 3: 1-way ANOVA body_mass ~ binomial

hist(residuals(fit3),
     main = "Histogram of residuals for 
     Model 3: 1-way ANOVA body_mass ~ binomial",
     xlab = "Residuals for Model 3: 1-way ANOVA body_mass ~ binomial")

shapiro.test(residuals(fit3))

```

```{r }

# Model 4: 2-way additive ANOVA body_mass ~ sex + binomial

hist(residuals(fit4),
     main = "Histogram of residuals for 
     Model 4: 2-way additive ANOVA body_mass ~ sex + binomial",
     xlab = "Residuals for Model 4: 2-way additive ANOVA body_mass ~ sex + binomial")

shapiro.test(residuals(fit4))

```

```{r }

# Model 5: 2-way factorial ANOVA body_mass ~ sex * binomial

hist(residuals(fit5),
     main = "Histogram of residuals for 
     Model 5: 2-way factorial ANOVA body_mass ~ sex * binomial",
     xlab = "Residuals for Model 5: 2-way factorial ANOVA body_mass ~ sex * binomial")

shapiro.test(residuals(fit5))

```

**What do you conclude about residual normality based on the numerical and graphical diagnostics?**

The p-value for the first model, the simple linear regression, is by far the smallest one since it is 2.2e-16. None of the p-values are higher than 0.05, but the one for the second model (1-way ANOVA body_mass ~ sex) would be the highest one with 0.0001541. The p-values for the rest of the models are close to the half of this value. Therefore, the numerical exploration would indicate that we can reject the null hypothesis (the values of residuals being normally distributed) for all models.

However, in the graphical exploration, we can see that there are normal patterns for the last four models. For the first model, although there is a peak of amount of residuals and the amount tends to decrease in both tails, the values are very highly concentrated in two ranges and we cannot see a pattern that seems to be normal.

There is a conflict between the numerical and the graphical diagnostics. However, I would say it would be safe to assume a normal distribution for the residuals of the last four models. I would not assume a residual normality for the first model, since both the numerical and graphical explorations do not show normality.

**Are violations of the normality assumption equally severe for all the models?**

No. Violations of the normality distribution are much higher for the first model, both in a graphical and a numerical exploration. The other four models show an approximate normal pattern for the graphical exploration and their p-values are way higher than the one for the first model, 

## Model Interpretation

### Body Length

Print the model coefficient table using summary() and answer the following:

```{r }

# Model 1: simple linear regression body_length ~ body_mass

knitr::kable(coef(summary(fit1)))

```

**What is the magnitude of the mass/length relationship?**

0.8755 mm/g

**What is the expected body length of an an animal that weighs 100g?**

163.67 mm

**What is the expected body length of an animal that weighs 0g?**

76.12 mm


### Body Mass: Model Coefficients

Print the model coefficient tables for each of the body mass model fits.

```{r }

# Model 2: 1-way ANOVA body_mass ~ sex

knitr::kable(coef(summary(fit2)))

```

```{r }

# Model 3: 1-way ANOVA body_mass ~ binomial

knitr::kable(coef(summary(fit3)))

```

```{r }

# Model 4: 2-way additive ANOVA body_mass ~ sex + binomial

knitr::kable(coef(summary(fit4)))

```

```{r }

# Model 5: 2-way factorial ANOVA body_mass ~ sex * binomial

knitr::kable(coef(summary(fit5)))

```

**What is the base level for sex?**

Female.

**What is the base level for binomial?**

Delomys dorsalis.

**Which sex is heavier?**

Male.

**Which species is heavier?**

Delomys dorsalis.

### Body Mass: ANOVA

Print the ANOVA tables for each of the body mass models.

```{r }


# Model 2: 1-way ANOVA body_mass ~ sex

knitr::kable(anova(fit2))

```

```{r }

# Model 3: 1-way ANOVA body_mass ~ binomial

knitr::kable(anova(fit3))

```

```{r }

# Model 4: 2-way additive ANOVA body_mass ~ sex + binomial

knitr::kable(anova(fit4))

```

```{r }

# Model 5: 2-way factorial ANOVA body_mass ~ sex * binomial

knitr::kable(anova(fit5))

```

**Are sex and species significant predictors for body mass?**

Yes. Both p-values are extremely low (0.0001951 for sex and 0 for species), so, we can reject the null hypothesis of ANOVA (the average value of body mass being the same for all groups). Therefore, both sex and species are significant predictors for body mass.

**Is there a significant interaction?**

No. The p-value for the interaction between sex and species is extremely high (0.9504424), so, we cannot reject the null hypothesis of ANOVA (the average value of body mass being the same for all groups). Therefore, the interaction between sex and species is not significant.

**Does the significance (as measured by p-value) of either of the main effects (sex and species) differ much between the single-predictor models, the additive model, and the interactive model?**

***Sex:***

Single-predictor: 0.0001951

Additive: 0.0001144

Interactive: 0.0001150

***Species:***

Single-predictor:0

Additive: 0

Interactive: 0

So, the answer would be no for both.The significance of sex differs by a very little amount among models and the significance  of species does not differ at all among models.

## Model Comparison: Body Mass

You built four different models of body mass. How do you choose the best one?

One option is to choose the model with the lowest AIC. You can calculate AIC using the appropriately named AIC() function.

Create a code chunk that calculates the AIC values for each of the body mass models.

```{r }
# Model 2: 1-way ANOVA body_mass ~ sex

AIC(fit2)

# Model 3: 1-way ANOVA body_mass ~ binomial

AIC(fit3)

# Model 4: 2-way additive ANOVA body_mass ~ sex + binomial

AIC(fit4)

# Model 5: 2-way factorial ANOVA body_mass ~ sex * binomial

AIC(fit5)
```

**Which two models have the lowest AIC?**

Model 4: 12896.73

Model 5: 12898.72

**Which of the two models with lowest AIC scores would you select?**

Model 4: 2-way additive ANOVA body_mass ~ sex + binomial

**Explain your decision based on model fit and the complexity/understanding tradeoff**

I would choose Model 4 not only because it has the lowest AIC value, but also because with the ANOVA analysis that we performed for each model, we could verify that both sex and species are significant predictors for body mass, but the interaction between sex and species is not significant. Therefore, I do not think it would be necessary to include the interaction of Model 5 in the final model.